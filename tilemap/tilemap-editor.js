!async function(t){t=t.gui.Component;const a={PEN:"pen",ERASER:"eraser"};t.initialState={width:16,height:16,size:16,scaling:2,tool:a.PEN,background:"#ffffff",tileData:null};class i{constructor(t,e,i){this.row=Math.floor(e/i),this.col=Math.floor(t/i),this.size=i}equals(t){return this.row==t.row&&this.col==t.col}}class e extends t{static get observedState(){return[]}constructor(){super(),this.state={dx:0,dy:0},this.prevTile=new i}connectedCallback(){super.connectedCallback(),this.initialContext()}stateChangedCallback(t,e,i){e===i||"dx"!==t&&"dy"!==t||(this.drawingBoard.style.translate=`${this.state.dx}px ${this.state.dy}px`)}initialContext(){this.ctx=this.drawingBoard.getContext("2d"),this.ctx.globalAlpha=1}resetData(){}openMap(t){}newMap(t,e){}resizeMap(t,e){}importMap(){}downloadMap(){}setTile(t){}draw(t,e){}erase(t,e){}handleWheel(t){t.preventDefault(),t.stopPropagation();let e=this.state.dx-t.deltaX/10,i=this.state.dy-t.deltaY/10;0<e&&(e=0),0<i&&(i=0);t=this.drawingBoard.getBoundingClientRect();Math.abs(e)>t.width&&(e=-t.width),Math.abs(i)>t.height&&(i=-t.height),this.setState({dx:e,dy:i})}handleMouseDown(t){t.preventDefault(),this.prevTile=new i,this.drawing=!0;const e=()=>{this.drawing=!1,document.removeEventListener("mouseup",e)};document.addEventListener("mouseup",e)}handleMouseMove(t){var e,i;t.preventDefault(),this.drawing&&(e=this.drawingBoard.getBoundingClientRect(),i=t.clientX-e.left,t=t.clientY-e.top,i=Math.floor(this.state.width*i/this.drawingBoard.clientWidth),t=Math.floor(this.state.height*t/this.drawingBoard.clientHeight),this.state.tool===a.PEN?(e=new Pixel(i,t)).equals(this.prevPixel)||(this.prevPixel=e,this.draw(e.x,e.y)):this.state.tool===a.ERASER&&this.erase(i,t))}handleTouchMove(t){t.preventDefault();var e=this.drawingBoard.getBoundingClientRect(),i=t.touches[0].clientX-e.left,t=t.touches[0].clientY-e.top,i=Math.floor(this.state.width*i/this.drawingBoard.clientWidth),t=Math.floor(this.state.height*t/this.drawingBoard.clientHeight);this.state.tool===a.PEN?(e=new Pixel(i,t)).equals(this.prevPixel)||(this.prevPixel=e,this.draw(e.x,e.y)):this.state.tool===a.ERASER&&this.erase(i,t)}handleMouseUp(t){var e,i;t.preventDefault(),this.drawing=!1,void 0===this.prevPixel.x&&(e=this.drawingBoard.getBoundingClientRect(),i=t.clientX-e.left,t=t.clientY-e.top,i=Math.floor(this.state.width*i/this.drawingBoard.clientWidth),t=Math.floor(this.state.height*t/this.drawingBoard.clientHeight),this.state.tool===a.PEN?(this.prevPixel=new Pixel(i,t),this.draw(i,t)):this.state.tool===a.ERASER?this.erase(i,t):this.state.tool===a.FILL?this.fill(i,t,this.data[i][t]):this.state.tool===a.PICKER&&"transparent"!==this.data[i][t]&&({h:e,s:i,v:t}=hexToHsv(this.data[i][t]),this.setState({color:e,saturation:i,brightness:t}))),this.setState("imageData",this.drawingBoard.toDataURL())}render(){return`
                <div
                    onwheel="this.handleWheel"
                    class="tile-map-editor-wrapper"
                >
                    <canvas
                        id="drawing-board"
                        style="background:${this.state.background}"
                        _onmousedown="this.handleMouseDown"
                        _ontouchmove="this.handleTouchMove"
                        _onmousemove="this.handleMouseMove"
                        _onmouseup="this.handleMouseUp"
                    ></canvas>
                </div>
            `}}customElements.define("tile-map-editor",e)}(Scratch);